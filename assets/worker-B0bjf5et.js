function O(t,e,a){return 1n<<BigInt(e*a+t)}function q(t){const e=Math.min(...t.map(n=>n.x)),a=Math.min(...t.map(n=>n.y)),c=t.map(n=>({x:n.x-e,y:n.y-a}));return c.sort((n,l)=>n.y-l.y||n.x-l.x),c}function E(t){return t.map(e=>({x:e.y,y:-e.x}))}function C(t){return t.map(e=>`${e.x},${e.y}`).join(";")}function F(t,e){const a=[];let c=t;const n=e?4:1;for(let l=0;l<n;l+=1){const s=q(c),f=C(s);a.some(u=>C(u)===f)||a.push(s),c=E(c)}return a}function $(t,e,a,c){const n=[];return F(t.cells,t.allowRotate).forEach(s=>{const f=Math.max(...s.map(i=>i.x)),u=Math.max(...s.map(i=>i.y)),h=e-(f+1),M=a-(u+1);for(let i=0;i<=M;i+=1)for(let w=0;w<=h;w+=1){let k=0n;const d=Array.from({length:a},()=>0),p=Array.from({length:e},()=>0);let P=!0;for(const v of s){const I=v.x+w,S=v.y+i,r=O(I,S,e);if((c&r)!==0n){P=!1;break}k|=r,d[S]+=1,p[I]+=1}P&&n.push({pieceId:t.id,mask:k,rowDelta:d,colDelta:p})}}),n}function j(t,e,a){const c=Array.from({length:a},()=>0),n=Array.from({length:e},()=>0);for(let l=0;l<a;l+=1)for(let s=0;s<e;s+=1){const f=1n<<BigInt(l*e+s);(t&f)!==0n&&(c[l]+=1,n[s]+=1)}return{row:c,col:n}}function K(t,e,a,c){let n=0;for(let s=c;s<a.length;s+=1)n+=a[s].piece.cells.length;let l=0;for(let s=0;s<e.length;s+=1)l+=e[s]-t[s];return n>=l}function G(t,e={}){const{maxSolutions:a=100,onProgress:c,onSolution:n,shouldStop:l}=e,s=performance.now(),f=[],u=new Map,h=t.blockedMask|t.fixedMask;t.pieces.forEach(r=>{u.set(r.id,$(r,t.width,t.height,h))});const M=t.pieces.flatMap(r=>Array.from({length:r.count},()=>({piece:r,placements:u.get(r.id)??[],prevSamePieceIndex:-1})));M.sort((r,y)=>r.placements.length-y.placements.length);const i=M,w=new Map;for(let r=0;r<i.length;r+=1){const y=i[r].piece.id,x=w.get(y);x!==void 0&&(i[r].prevSamePieceIndex=x),w.set(y,r)}const k=j(t.fixedMask,t.width,t.height),d=[...k.row],p=[...k.col];let P=0,v=0;const I=Array(i.length).fill(-1),S=(r,y,x)=>{if(l?.())return;P+=1;const b=performance.now();if(c&&b-v>100&&(v=b,c({nodes:P,solutions:f.length,elapsedMs:Math.floor(b-s)})),r===i.length){if(d.every((g,m)=>g===t.rowTargets[m])&&p.every((g,m)=>g===t.colTargets[m])){const g=[...x];f.push(g),n?.(g)}return}if(f.length>=a||!K(d,t.rowTargets,i,r))return;const{placements:R,prevSamePieceIndex:B}=i[r],X=B>=0?I[B]+1:0;for(let g=X;g<R.length;g+=1){const m=R[g];if((m.mask&y)!==0n)continue;let D=!1;for(let o=0;o<t.height;o+=1)if(d[o]+m.rowDelta[o]>t.rowTargets[o]){D=!0;break}if(!D){for(let o=0;o<t.width;o+=1)if(p[o]+m.colDelta[o]>t.colTargets[o]){D=!0;break}if(!D){for(let o=0;o<t.height;o+=1)d[o]+=m.rowDelta[o];for(let o=0;o<t.width;o+=1)p[o]+=m.colDelta[o];x.push(m),I[r]=g,S(r+1,y|m.mask,x),I[r]=-1,x.pop();for(let o=0;o<t.height;o+=1)d[o]-=m.rowDelta[o];for(let o=0;o<t.width;o+=1)p[o]-=m.colDelta[o];if(f.length>=a)return}}}};return S(0,t.fixedMask,[]),f}const T=self;let A=!1;T.onmessage=t=>{const e=t.data;if(e.type==="stop"){A=!0;return}if(e.type==="start"){A=!1;const a=performance.now(),{puzzle:c,maxSolutions:n}=e,l=G(c,{maxSolutions:n,shouldStop:()=>A,onProgress:({nodes:u,solutions:h,elapsedMs:M})=>{const i={type:"progress",nodes:u,solutions:h,elapsedMs:M};T.postMessage(i)},onSolution:u=>{const h={type:"solution",solution:u};T.postMessage(h)}}),s=Math.floor(performance.now()-a),f={type:"done",solutions:l.length,elapsedMs:s};T.postMessage(f)}};
